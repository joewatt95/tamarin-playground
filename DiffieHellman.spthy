theory DiffieHellman
begin

builtins: hashing, asymmetric-encryption, diffie-hellman

// functions: h/1, aenc/2, adec/2, pk/1
// equations:
//   adec(aenc(m, pk(k)), k) = m

// functions: to_pub_key/1, to_sess_key/2
// equations:
//   to_pub_key(priv_key) = g ^ priv_key,
//   to_sess_key(priv_key_A, pub_key_B) = pub_key_B ^ priv_key_A

// macros:
//   to_pub_key(priv_key) = 'g' ^ priv_key,
//   to_sess_key(priv_key_A, pub_key_B) = pub_key_B ^ priv_key_A

// predicates:
//   BackgroundTheory() <=> (
//     (All x y #i. Eq(x, y) @ #i ==> x = y)
//   )

// TODO: Figure out why this is causing an infinite loop in maude on startup
// equations:
//   to_sess_key(priv_key, to_pub_key(priv_key_0)) =
//   to_sess_key(priv_key_0, to_pub_key(priv_key))

rule Gen_priv_pub_keys :
  [Fr(~priv_key)]
  -->
  [!PrivPubKeys($A, ~priv_key, 'g' ^ ~priv_key)]

rule Send_pub_key :
  [!PrivPubKeys(A, priv_key, pub_key)]
  -->
  [Out(pub_key)]

rule Reveal_priv_key :
  [!PrivPubKeys(A, priv_key, pub_key)]
  --[RevealPrivKey(A)]->
  [Out(priv_key)]

rule Gen_sess_key :
  let
    sess_key = pub_key_B ^ priv_key_A
    // sess_key_B = pub_key_A ^ priv_key_B 
  in
  [In(pub_key_A), In(pub_key_B),
    !PrivPubKeys(A, priv_key_A, pub_key_A),
    !PrivPubKeys(B, priv_key_B, pub_key_B)]
  --[SessKeyCreated(A, B, sess_key), _restrict(not A = B)]->
  [SessKey(A, B, sess_key)]

// rule Gen_sess_key_start :
//   let
//     sess_key_alice = ('g'^bob_priv_key)^alice_priv_key
//     sess_key_bob = ('g'^alice_priv_key)^bob_priv_key
//   in
//   [In('g'^alice_priv_key), In('g'^bob_priv_key),
//     !Priv(A, alice_priv_key), !Priv(B, bob_priv_key)]
//   --[SessKeyGenStarted(A, B, sess_key_alice), _restrict(not A = B)]->
//   [SessKeyGenStarted(A, B, sess_key_alice)]

// rule Gen_sess_key_end :
//   [SessKeyGenStarted(A, B, sess_key_alice)]
//   -->
//   [SessKey(A, B, sess_key_alice)]

rule Reveal_sess_key :
  [SessKey(A, B, sess_key)]
  --[RevealSessKey(A, B, sess_key)]->
  [Out(sess_key)]

lemma Client_session_key_honest_setup :
  exists-trace
  "Ex A B sess_key #i.
    SessKeyCreated(A, B, sess_key) @ #i &
    not(Ex #r. RevealPrivKey(A) @ r) &
    not(Ex #r. RevealPrivKey(B) @ r)"

// lemma Test :
//   all-traces
//   "All A B. (
//     not A = B &
//     not(Ex #r. RevealPrivKey(A) @ r) &
//     not(Ex #r. RevealPrivKey(B) @ r)
//   ) ==> (
//     Ex sess_key #i. SessKeyCreated(A, B, sess_key) @ #i
//   )"

end